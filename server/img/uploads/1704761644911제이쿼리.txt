- jQuery

리액트 뷰 <---> 제이쿼리

   1) jQuery의 목적  :*********자바 스크립트의 브라우저 호환성 문제와 복잡한 코드로 인한 문제를 해결하기 위함
 
  jQuery는 2006년 미국의 존 레식(John Resig)이 뉴욕시 바캠프(Barcamp)에서 처음 소개한 ‘자바 스크립트 라이브러리’입니다. 
  코드가 브라우저의 영향을 받아 작동하지 못하는 문제를 해결하기 위해 개발되었는데요.
  ******코드와의 호환성 문제를 많이 이르키는 브라우저들이 있습니다. 
  우리나라에서 많이 사용했던 IE(Internet Exploer)가 대표적인데요. 
  IE에서는 버전이나 호환성의 문제로 코드가 제대로 작동하지 않을 때가 많았습니다. 
  *******이 문제를 해결하고자 ‘크로스 브라우징’ 기능을 가진 jQuery가 탄생했습니다. 
  ********크로스 브라우징이란 다양한 브라우저에서 같은 코드로 동일한 동작을 할 수 있게 하는 기능으로 코드가 브라우저에 따라 제대로 작동하지 않는 문제를 해결할 수 있습니다.
  브라우저의 버전에 따라 작동하지 않는 코드를  jQuery로 변경해서 사용하면 브라우저 문제 없이 사용할 수 있습니다. 
  
  **********자바 스크립트는  동적인 기능 구현을 할 수 있지만 코드가 너무 길어지고 복잡해지는 단점이 있습니다. 
  ********하지만 jQuery를 사용하면 같은 기능도 간략하고 단순한 코드로 구현할 수 있죠
  jQuery는 자바 스크립트의 코드를 단순하게 변경하고 html 요소를 간단하고 편리하게 사용하는 기능이 내재되어 있습니다
  
  *********장점: 첫 번째로 jQuery는 DOM(Document Object Model) 구조 탐색이 매우 뛰어납니다.
  jQuery는 css 검색 스타일로 원하는 위치를 정확하게 뽑아내어 요소를 추가/삭제하기 때문에 더 간단하고 편리하게 원하는 요소를 찾아낼 수 있습니다. 
  두번째로 크로스 브라우징 
  jQuery는 모든 브라우저를 지원하고 있어, 코드가 깨지지 않고 동작합니다
  
  단점:우선 첫 번째로 jQuery는 순수 자바 스크립트를 이용해 구현한 코드보다 속도가 현저히 느립니다. 
   jQuery가 동작할 때는 라이브러리에 걸쳐 해당 브라우저에 맞는 네이티브 자바 스크립트로 변환 시켜야 하기에 코드가 많아지면 속도가 느려집니다. 
   두 번째로 코드가 간결해서 쉽게 느낄 수도 있지만 코드를 관리하는 부분에서는 힘들 수도 있습니다.
   자바 스크립트를 배우지 않고 바로 jQuery를 배우는 사람이 늘어나면서  jQuery의 원리를 모르고 코드를 잘못 사용하는 경우가 생기게 되었고, 
   이에 따라 프로젝트를 유지, 관리하는 데 어려움을 겪는 경우가 발생
  
  
  제이쿼리의 추락원인 

2015년.. 웹표준이 잡히기 ㅅㅣ작하면서..
자바스크립트 업데이트..가진행되면서..
성능적인 부분은...
사이트가 커짐에 따라 ㅈㅔ이쿼리의 필요성이 없어짐..
사이트가 커지면 가상돔을 주로 사용하게도ㅣ니까..

  
 
  jQuery가 좋은 라이브러리라서 사용했던 것이 아니라, 당면한 문제를 해결하기 위한 임시방편(band aid)이었기 때문이다. 
  과거와 달리 크로스 브라우징 이슈도 적어졌고 가상돔의 인기로 돔을 직접 조작할 필요가 없어짐 
  
  <웹 표준 API의 확장>
W3C(World Wide Web Consortium)·WHATWG(Web Hypertext Application Technology Working Group)와 같은 단체의 노력으로 웹 표준은 끊임없이 발전해왔습니다. 
그러나 그 노력의 이면에는 제이쿼리와 같은 라이브러리를 사용해야만 활용 가능했던 편의 기능을 브라우저에서 기본 API로 제공하는 것도 포함되어 있었습니다. 
단적인 예가 Fetch API입니다. 이 API는 제이쿼리에서 가장 널리 사용되던 jQuery.ajax() 메소드 수준의 편의성과 유연성을 제공합니다. 
이와 같이 높은 기능성을 갖춘 웹 표준 API가 늘어나면서 제이쿼리의 입지가 약화하고 있습니다.


<웹브라우저 환경의 변화>
제이쿼리가 본격적으로 사용되기 시작한 2007~2008년은 인터넷 익스플로러(Internet Explorer)가 전 세계 웹브라우저 시장의 60% 이상을 점유하면서 절대 강자로 군림하고 있었습니다. 
인터넷 익스플로러는 마이크로소프트의 다른 애플리케이션처럼 안정적인 변화를 추구하여 버전 업그레이드가 느렸으며 데스크톱 기반의 윈도우(Windows) 환경에 주력하였습니다. 
따라서 생산성과 가독성이 높은 간결한 코드를 작성하기 위해서는 제이쿼리가 필요했습니다. 
그러나 2008년 크롬(Chrome)이 등장하면서 브라우저 시장은 일대 변혁을 맞이했습니다. 
윈도우, 맥(Mac), 리눅스(Linux) 등의 데스크톱 OS뿐만 아니라 안드로이드 등의 모바일 OS도 지원하는 크롬은 인터넷 익스플로러의 점유율을 빠르게 잠식했으며, 
2013년 이후 줄곧 글로벌 시장점유율 1위를 지키고 있습니다. 크롬은 여러 부분에서 인터넷 익스플로러와 달랐습니다. 
성능이 더 우수한 렌더링 엔진을 탑재하였고 빠른 버전 업그레이드를 위해 웹 표준을 신속하게 반영하였습니다. 
그 결과 제이쿼리와 같은 라이브러리를 사용하지 않고도 양질의 웹 애플리케이션 구현이 가능해졌습니다.
  
  <가상 돔(Virtual DOM)을 사용하는 라이브러리의 등장>
  
 리액트, 뷰 와 같은 가상 돔을 사용하는 라이브러리, 프레임워크가 나타남에 따라 돔을 직접 조작하는 제이쿼리의 필요성이 줄어듭니다

  
   ***************2) 현재 jQuery를 사용할 경우 주의 사항은?
   서로다른 플러그인을 사용할경우 충돌 날 지도..

   제이쿼리는 코드가 간결하기 때문에 사람들이 쉽게 생각하는 경우가 있습니다. 
   코드가 짧기 때문에 평소보다 코드를 많이 붙이게 되고 코드가 꼬이거나 중복되는 경우가 많습니다. 
   제이쿼리의 원리를 모른 채 코딩하여 코드의 품질이 낮아져 오히려 코드관리가 어려워 질 수 있음 
   
   
 결론: 제이쿼리 자체가 문제가 있다기 보다는 제이쿼리를 어떻게 사용하는지가 중요하다고 생각함
 제이쿼리는 자바스크립트의 라이브러리 중 하나일 뿐이고 필요에 의해 제이쿼리를 적절하게 사용한다면.. 문제될것은 없다고 생각함.
 
   


- innerHTML VS innerText VS textContext
공통점과 차이점 한줄씩  element와 node의 차이............. 알아보기 ..


*********innerHTML : 'Element'의 속성으로, 해당 Element의 HTML, XML을 읽어오거나, 설정할 수 있음  위험하다.. 태그와 css가 그대로 노출.. 보안상 문제가 발생.. 주의...
xss공격대상.. 동적으로 코드를 생성가능.. 

// html 코드와 함께 작성 가능
document.documentElement.innerHTML = "<p>innerHTML</p>"
// 스타일 적용
document.documentElement.innerHTML = 
  "<span style='color:blue'>innerHTML</span>"
  

  
*********innerText :'Element'의 속성으로, 해당 Element 내에서 사용자에게 '보여지는' 텍스트 값을 읽어옴
--css에 의존적이기 때문에 원하는 결과를 얻지 못할 수 있고 textcontent보다 처리가 느리대


// innerHTML과 달리 text값만 다루기 때문에 html태그 사용 불가능
document.documentElement.innerText = "innerText"

// html태그를 넣으면 태그도 text값으로 인식하고 
// <p>innerText</p> 문자열 그대로 적용함.
document.documentElement.innerText = "<p>innerText</p>"



*********textContent : textContent는 'Node'의 속성으로, innetText와는 달리 <script>나 <style> 태그와 상관없이 해당 노드가 가지고 있는 텍스트 값을 그대로 읽음
>>권장됨..



<div id='content'>
  안녕~ 
  <span style='display:none'>innerText는 나를 볼 수 없어😏</span>
</div>



1)innerHTML
const content = document.getElementById('content');

console.log(content.innerHTML);
// html 전체를 다 가져옴

// 안녕~ 
// <span style='display:none'>innerText는 나를 볼 수 없어😏</span>


2)innerText
  
console.log(content.innerText);
// 사용자에게 보여지는 텍스트만 가져옴
// 숨겨진 텍스트는 사용자에게 보여지지 않기 때문에 안녕~만 가져옴

// 안녕~

3)textContent

console.log(content.textContent);
// 숨겨진 텍스트까지 포함해서 텍스트값을 모두 다 가져옴

// 안녕~
// innerText는 나를 볼 수 없어😏